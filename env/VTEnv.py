import numpy as np
import random
import os
import gymnasium as gym
import hashlib
from .virus_total import VirusTotal
from .controls import modifier 
from IPython.display import clear_output

ACTION_LOOKUP = {i: act for i, act in enumerate(modifier.ACTION_TABLE.keys())}

class VirusTotalEnv(gym.Env):
  def __init__(self,file_path, output_path ="output",max_steps = 7, threshold = 0.6, api_key ="",random = True):

    self.iteration = 0
    self.random = random
    self.file_path = file_path
    self.output_path = output_path
    self.max_steps = max_steps
    self.current_step = 0 
    self.steps = 0
    self.action_space = gym.spaces.Discrete(len(ACTION_LOOKUP)) #acciones a tomar
    # self.observation = observation #Numero de observaciones a hacer.
    # self.reward_range = get_reward_range(reward_method) #rango del reward
    self.max_len = 252416
    self.observation_space =  gym.spaces.Box(
            low=0,
            high=256,
            shape=(self.max_len,),
            dtype=np.uint8,
        )


    self.threshold = threshold
   
    self.vt = VirusTotal(api_key)
    self.actions = []
    self.rewards = []
    self.current_reward = 0
    self.reward_episode = []
    self.stats = []
    self.register = {}
    self.reset()
    self.best_score = 1


  def step(self, action_ix):
    self.steps += 1
    sha256_hash = hashlib.sha256()
    action = ACTION_LOOKUP[action_ix]
    self.actions.append(action)
    self.bytez = modifier.modify_sample(self.bytez, action)
  
    with open(f"{self.output_path}/{self.file_name}", "wb") as dest_file:
        dest_file.write(self.bytez)
        sha256_hash.update(self.bytez)
        computed_hash = sha256_hash.hexdigest()
    
    done = False
    if self.current_step >= self.max_steps:
      truncated = True
    else:
      truncated = False

    #Calculamos el reward
    
    reward = self.get_reward(computed_hash)
  
   
    self.current_reward += reward

    if reward > 1/self.threshold :
        done = True
        self.reward_episode.append(self.current_reward)
        with open(f"evaded/{self.file_name}", "wb") as dest_file:
          dest_file.write(self.bytez)
          
    info = {
            'reward':self.rewards,
            'step':self.current_step,
            'actions':self.actions,
            'stats':self.stats}

    self.rewards.append(reward)
    self.current_step += 1
    clear_output(wait=True)
    print(f"Reward: {reward}")
    print(f"Step: {self.steps}")
    return self.get_obs() ,reward,done,truncated,info

  

  def get_reward(self,computed_hash):

    if computed_hash in self.register:
      score = self.register[computed_hash] 
    else:
      stats, score = self.vt.score(f"{self.output_path}/{self.file_name}")
      self.register[computed_hash] = score
      self.stats.append(stats)
    
    if score == 0: 
      return 10

    reward = (1/(abs(score)))

    if score < self.best_score:
      self.best_score = score
      return reward 
    else:
      return self.best_score - score
  
  def get_obs(self):
    """Ajustar el tama単o de un bytearray a un tama単o fijo, agrandando o encogiendo."""
    current_size = len(self.bytez)

    bytez = self.bytez
    if current_size < self.max_len:
        # Agrandar el bytearray
        padding_size = self.max_len - current_size
        bytez = self.bytez + bytearray(padding_size)  # Agregar ceros para alcanzar el tama単o fijo

    elif current_size > self.max_len:
        # Encoger el bytearray
        bytez = self.bytez[:self.max_len]  # Truncar al tama単o fijo

    return bytez

  def reset(self,seed = None):
    self.current_reward = 0
    self.best_score = 1
    self.current_step = 0
    if self.random == True:
      self.file_name = random.sample(os.listdir(self.file_path),1)[0]
    else:
      self.file_name = os.listdir(self.file_path)[self.iteration]
      self.iteration += 1
    with open(self.file_path + self.file_name, "rb") as src_file:
         self.bytez = bytearray(src_file.read())  # Leer el archivo original

    # Guardar el contenido en el nuevo archivo
    with open(f"{self.output_path}/{self.file_name}", "wb") as dest_file:
        dest_file.write(self.bytez) 
    return self.get_obs(),{}
    
    